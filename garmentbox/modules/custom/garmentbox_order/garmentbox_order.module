<?php
/**
 * @file
 * Code for the Garmentbox Order feature.
 */

include_once 'garmentbox_order.features.inc';

/**
 * Implements hook_menu().
 */
function garmentbox_order_menu() {
  $items['season/%node/orders'] = array(
    'title callback' => 'garmentbox_order_get_page_title',
    'title arguments' => array(1, 'orders'),
    'page callback' => 'garmentbox_order_get_orders_table',
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
    'access callback' => 'node_access',
    'access arguments' => array('view', 1),
  );

  return $items;
}

/**
 * Build the page title for season order page.
 *
 * @param $node
 *   The season node.
 *
 * @return
 *   The title string.
 */
function garmentbox_order_get_page_title($node) {
  return t('@season - Orders', array('@season' => $node->title));
}

/**
 * Show the orders of a season or item.
 *
 * @param $nid
 *   Season or item node ID.
 *
 * @return
 *   Rendered table with orders info.
 */
function garmentbox_order_get_orders_table($node) {
  // Group the rows by inventory line node.
  if (!$data = garmentbox_order_get_orders_data($node)) {
    return t('No orders created yet.');
  }

  drupal_add_js(drupal_get_path('module', 'garmentbox_order') . '/js/orders_table.js');

  $header = array(
    t('Order'),
    t('Customer'),
    t('Total price'),
    t('Total items'),
    t('Last delivery date'),
    t('Next delivery date'),
    t('Status'),
  );

  $inventory_header = array();
  $inventory_header[] = t('Variation');

  $wrapper = entity_metadata_wrapper('node', $node);
  $company_nid = $wrapper->og_company->getIdentifier();

  $vocabulary = taxonomy_vocabulary_machine_name_load("size_$company_nid");
  $size_tree = taxonomy_get_tree($vocabulary->vid);

  foreach ($size_tree as $term) {
    $inventory_header[] = $term->name;
  }
  $inventory_header[] = t('Total');
  $inventory_header[] = t('Status');

  $order_table = array();
  foreach ($data as $order_nid => $row) {
    $order_row = array(
      'data' => array(),
      'class' => array('expandable'),
      'ref' => 'order-inventory-' . $order_nid,
    );

    $expand_link = '<a href="#" class="expander collapsed"></a>';
    $order_row['data'][] = $expand_link . $row['order_info']['label'];
    $order_row['data'][] = $row['order_info']['customer'];
    // @todo:
    $order_row['data'][] = t('N/A');
    $order_row['data'][] = $row['order_info']['total_items'];
    $order_row['data'][] = $row['order_info']['last_delivery_timestamp'] ? format_date($row['order_info']['last_delivery_timestamp'], 'garmentbox_short_date') : t('N/A');
    $order_row['data'][] = $row['order_info']['next_delivery_timestamp'] ? format_date($row['order_info']['next_delivery_timestamp'], 'garmentbox_short_date') : t('N/A');
    $order_row['data'][] = $row['order_info']['status'];

    $order_table[] = $order_row;

    $inventory_table = array();
    foreach ($row['inventory_lines'] as $inventory_line) {
      $row = array();
      $row[] = $inventory_line['label'];

      $total = 0;
      foreach($size_tree as $term) {
        $row[] = !empty($inventory_line['quantity_info']['size'][$term->tid]) ? $inventory_line['quantity_info']['size'][$term->tid] : 0;
      }

      $row[] = array('data' => $inventory_line['quantity_info']['total_items'], 'class' => array('emphasized'));
      $row[] = $inventory_line['type'];

      $inventory_table[] = $row;
    }
    $variables = array(
      'header' => $inventory_header,
      'rows' => $inventory_table,
    );

    $order_table[] = array(
      'data' => array(
        array(
          'data' => theme('table', $variables),
          'colspan' => 7,
        ),
      ),
      'class' => array('hidden'),
      'id' => 'order-inventory-' . $order_nid,
    );
  }

  $variables = array(
    'header' => $header,
    'rows' => $order_table,
    'attributes' => array('id' => 'orders'),
  );
  return theme('table', $variables);
}

/**
 * Fetch the raw data for the orders table.
 *
 * @param $node
 *   Season node.
 *
 * @return
 *   Array with the query result.
 */
function garmentbox_order_get_orders_data($node) {
 // Get all the orders that belong to the season.
  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'order')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->fieldCondition('field_season', 'target_id', $node->nid)
    ->propertyOrderBy('title')
    ->execute();

  if (empty($result['node'])) {
    return;
  }

  $orders = node_load_multiple(array_keys($result['node']));

  // Prepare the data array.
  $now = time();
  $data = array();
  foreach ($orders as $order) {
    $wrapper = entity_metadata_wrapper('node', $order);
    $data[$order->nid] = array();

    $order_label = $wrapper->label();
    $order_url = entity_uri('node', $wrapper->value());

    $customer_label = $wrapper->field_customer->label();
    $customer_url = entity_uri('node', $wrapper->field_customer->value());

    $data[$order->nid]['order_info'] = array(
      'label' => l($order_label, $order_url['path'], $order_url['options']),
      'customer' => l($customer_label, $customer_url['path'], $customer_url['options']),
      'status' => $wrapper->field_order_status->label(),
      'last_delivery_timestamp' => 0,
      'next_delivery_timestamp' => 0,
    );

    $order_total_items = 0;

    foreach ($wrapper->field_inventory_line_inline as $wrapper_li) {
      $node = $wrapper_li->value();
      $delivery_timestamp = $wrapper_li->field_delivery_date->value();

      $label = $wrapper_li->field_item_variant->label();
      $uri = entity_uri('node', $wrapper_li->field_item_variant->value());

      $data[$order->nid]['inventory_lines'][$node->nid] = array(
        // The title of the item-variant.
        'label' => l($label, $uri['path'], $uri['options']),
        'delivery_date' => $delivery_timestamp,
        'defective' => $wrapper_li->field_defective->value(),
        'type' => $wrapper_li->field_inventory_type->label(),
      );

      // Update last and next delivery dates.
      if ($delivery_timestamp > $now) {
        if ($delivery_timestamp > $data[$order->nid]['order_info']['last_delivery_timestamp']) {
          // Update the last delivery date that is going to be sent.
          $data[$order->nid]['order_info']['last_delivery_timestamp'] = $delivery_timestamp;
        }

        if (!$data[$order->nid]['order_info']['next_delivery_timestamp'] || $delivery_timestamp < $data[$order->nid]['order_info']['next_delivery_timestamp']) {
          // Update the next delivery date that is going to be sent.
          $data[$order->nid]['order_info']['next_delivery_timestamp'] = $delivery_timestamp;
        }
      }

      // Add the size and quantity info. We can't use the wrapper as we
      // have revisions.
      $total_items = 0;
      if (!empty($node->field_quantity_info[LANGUAGE_NONE][0]['value'])) {
        foreach ($node->field_quantity_info[LANGUAGE_NONE] as $delta => $value) {
          $item = field_collection_item_revision_load($value['revision_id']);
          $item_wrapper = entity_metadata_wrapper('field_collection_item', $item);
          $size = $item_wrapper->field_size->getIdentifier();
          $quantity = $item_wrapper->field_quantity_integer->value();
          $data[$order->nid]['inventory_lines'][$node->nid]['quantity_info']['size'][$size] = $quantity;
          $total_items += $quantity;
        }
      }
      $data[$order->nid]['inventory_lines'][$node->nid]['quantity_info']['total_items'] = $total_items;
      $order_total_items += $total_items;
    }
    $data[$order->nid]['order_info']['total_items'] = $order_total_items;
  }

  return $data;
}
